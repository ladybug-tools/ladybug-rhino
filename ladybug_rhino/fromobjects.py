"""Functions to translate entire Ladybug core objects to Rhino geometries.

The methods here are intended to help translate groups of geometry that are commonly
generated by several objects in Ladybug core (ie. legends, compasses, etc.)
"""
import math
import copy

try:
    from ladybug_geometry.geometry2d import Vector2D, Point2D, Ray2D, LineSegment2D, \
        Arc2D, Polyline2D, Polygon2D, Mesh2D
    from ladybug_geometry.geometry3d import Vector3D, Point3D, Ray3D, LineSegment3D, \
        Arc3D, Polyline3D, Plane, Mesh3D, Face3D, Polyface3D, Sphere, Cone, Cylinder
except ImportError as e:
    raise ImportError("Failed to import ladybug_geometry.\n{}".format(e))

try:
    from ladybug.legend import Legend, LegendParameters, LegendParametersCategorized
except ImportError as e:
    raise ImportError('\nFailed to import ladybug:\n\t{}'.format(e))

from .config import current_tolerance
from .fromgeometry import from_point2d, from_vector2d, from_ray2d, from_linesegment2d, \
    from_arc2d, from_polyline2d, from_polygon2d, from_mesh2d, \
    from_point3d, from_vector3d, from_ray3d, from_linesegment3d, from_arc3d, \
    from_plane, from_polyline3d, from_mesh3d, from_face3d, from_polyface3d, \
    from_sphere, from_cone, from_cylinder
from .togeometry import to_point3d, to_polyline3d
from .text import text_objects

try:
    import Rhino.Geometry as rg
except ImportError as e:
    raise ImportError("Failed to import Rhino document attributes.\n{}".format(e))


def legend_objects(legend):
    """Translate a Ladybug Legend object into Grasshopper geometry.

    Args:
        legend: A Ladybug Legend object to be converted to Rhino geometry.

    Returns:
        A list of Rhino geometries in the following order.

        -   legend_mesh -- A colored mesh for the legend.

        -   legend_title -- A bake-able text object for the legend title.

        -   legend_text -- Bake-able text objects for the rest of the legend text.
    """
    _height = legend.legend_parameters.text_height
    _font = legend.legend_parameters.font
    legend_mesh = from_mesh3d(legend.segment_mesh)
    legend_title = text_objects(legend.title, legend.title_location, _height, _font)
    if legend.legend_parameters.continuous_legend is False:
        legend_text = [text_objects(txt, loc, _height, _font, 0, 5) for txt, loc in
                       zip(legend.segment_text, legend.segment_text_location)]
    elif legend.legend_parameters.vertical is True:
        legend_text = [text_objects(txt, loc, _height, _font, 0, 3) for txt, loc in
                       zip(legend.segment_text, legend.segment_text_location)]
    else:
        legend_text = [text_objects(txt, loc, _height, _font, 1, 5) for txt, loc in
                       zip(legend.segment_text, legend.segment_text_location)]
    return [legend_mesh] + [legend_title] + legend_text


def compass_objects(compass, z=0, custom_angles=None, projection=None, font='Arial'):
    """Translate a Ladybug Compass object into Grasshopper geometry.

    Args:
        compass: A Ladybug Compass object to be converted to Rhino geometry.
        z: A number for the Z-coordinate to be used in translation. (Default: 0)
        custom_angles: An array of numbers between 0 and 360 to be used to
            generate custom angle labels around the compass.
        projection: Text for the name of the projection to use from the sky
            dome hemisphere to the 2D plane. If None, no altitude circles o
            labels will be drawn (Default: None). Choose from the following:

            * Orthographic
            * Stereographic

        font: Optional text for the font to be used in creating the text.
            (Default: 'Arial')

    Returns:
        A list of Rhino geometries in the following order.

        -   all_boundary_circles -- Three Circle objects for the compass boundary.

        -   major_azimuth_ticks -- Line objects for the major azimuth labels.

        -   major_azimuth_text -- Bake-able text objects for the major azimuth labels.

        -   minor_azimuth_ticks -- Line objects for the minor azimuth labels
                (if applicable).

        -   minor_azimuth_text -- Bake-able text objects for the minor azimuth
                labels (if applicable).

        -   altitude_circles -- Circle objects for the altitude labels.

        -   altitude_text -- Bake-able text objects for the altitude labels.

     """
    # set default variables based on the compass properties
    maj_txt = compass.radius / 20
    min_txt = maj_txt / 2
    xaxis = Vector3D(1, 0, 0).rotate_xy(math.radians(compass.north_angle))

    result = []  # list to hold all of the returned objects
    for circle in compass.all_boundary_circles:
        result.append(from_arc2d(circle, z))

    # generate the labels and tick marks for the azimuths
    if custom_angles is None:
        for line in compass.major_azimuth_ticks:
            result.append(from_linesegment2d(line, z))
        for txt, pt in zip(compass.MAJOR_TEXT, compass.major_azimuth_points):
            txt_pln = Plane(o=Point3D(pt.x, pt.y, z), x=xaxis)
            result.append(text_objects(txt, txt_pln, maj_txt, font, 1, 3))
        for line in compass.minor_azimuth_ticks:
            result.append(from_linesegment2d(line, z))
        for txt, pt in zip(compass.MINOR_TEXT, compass.minor_azimuth_points):
            txt_pln = Plane(o=Point3D(pt.x, pt.y, z), x=xaxis)
            result.append(text_objects(txt, txt_pln, min_txt, font, 1, 3))
    else:
        for line in compass.ticks_from_angles(custom_angles):
            result.append(from_linesegment2d(line, z))
        for txt, pt in zip(
                custom_angles, compass.label_points_from_angles(custom_angles)):
            txt_pln = Plane(o=Point3D(pt.x, pt.y, z), x=xaxis)
            result.append(text_objects(str(txt), txt_pln, maj_txt, font, 1, 3))

    # generate the labels and tick marks for the altitudes
    if projection is not None:
        if projection.title() == 'Orthographic':
            for circle in compass.orthographic_altitude_circles:
                result.append(from_arc2d(circle, z))
            for txt, pt in zip(compass.ALTITUDES, compass.orthographic_altitude_points):
                txt_pln = Plane(o=Point3D(pt.x, pt.y, z), x=xaxis)
                result.append(text_objects(str(txt), txt_pln, min_txt, font, 1, 0))
        elif projection.title() == 'Stereographic':
            for circle in compass.stereographic_altitude_circles:
                result.append(from_arc2d(circle, z))
            for txt, pt in zip(compass.ALTITUDES, compass.stereographic_altitude_points):
                txt_pln = Plane(o=Point3D(pt.x, pt.y, z), x=xaxis)
                result.append(text_objects(str(txt), txt_pln, min_txt, font, 1, 0))

    return result


def mesh_to_contours(mesh, values, legend_parameters=None,
                     smooth_iterations=1, smooth_strength=1, as_lb_geo=False):
    """Get Polylines for contours from a Rhino Mesh and associated values.

    Args:
        mesh: A Rhino Mesh for which contours will be derived.
        values: A list of numerical values to define how the mesh is contoured.
            The number of values must match the number of faces or vertices
            in the mesh.
        legend_parameters: Ladybug LegendParameters to be used to customize
            the number and min/max of the contours. If None, default legend
            parameters will be used. (DefaultL None).
        smooth_iterations: The number of times that the contours will be
            smoothed. (Default: 1).
        smooth_strength: A number between 0 and 1 to denote controls how much
            control points move towards the average of the neighboring control
            points. (Default: 1).
        as_lb_geo: Boolean to note wether the result shall be returned as
            ladybug geometry Polyline3D and LineSegment3D (true) or as Rhino
            Polyline and Line objects (False). (Default: False).

    Returns:
        A list of Rhino geometries in the following order.

        -   contours -- A list of lists where each sub-list represents
            contours associated with a specific threshold. Contours are
            composed of Rhino Polyline and Line objects.

        -   thresholds -- list of numbers for the threshold value associated
            with each contour. The length of this list matches the contours.
    """
    # check the input values and provide defaults
    tol = current_tolerance()
    val_count = len(values)
    face_match = val_count == mesh.Faces.Count
    assert face_match or val_count == mesh.Vertices.Count, \
        'Number of _values ({}) must match the number of mesh faces ({}) or ' \
        'the number of mesh vertices ({}).'.format(
            val_count, mesh.Faces.Count, mesh.Vertices.Count)
    l_par = legend_parameters if legend_parameters is not None else LegendParameters()

    # figure out the thresholds to be used for the contour lines
    if isinstance(l_par, LegendParametersCategorized):
        thresholds = l_par.domain
    else:
        legend = Legend(values, l_par)
        min_val, max_val = legend.legend_parameters.min, legend.legend_parameters.max
        if min_val == max_val:
            return [], []  # no contours to be generated
        thresholds = list(legend.segment_numbers)
        if legend.is_max_default:
            thresholds.pop(-1)  # no need to make a contour
        if legend.is_min_default:
            thresholds.pop(0)  # no need to make a contour
        if len(thresholds) == 0:  # ensure there is at least one threshold
            thresholds = [(max_val + min_val) / 2]

    # get the naked segments of the starting mesh
    init_naked_edges = []
    for geo in mesh.GetNakedEdges():
        lb_geo = to_polyline3d(geo)
        if isinstance(lb_geo, Polyline3D):
            init_naked_edges.extend(lb_geo.segments)
        else:
            init_naked_edges.append(lb_geo)

    # loop through the thresholds and generate contour lines
    contours = []
    for abs_thresh in thresholds:
        # remove faces below the threshold
        pattern, remove_i = [], []
        for i, val in enumerate(values):
            if val > abs_thresh:
                pattern.append(True)
            else:
                pattern.append(False)
                remove_i.append(i)
        if all(v for v in pattern):
            contours.append([])
            continue  # full mesh in contour; not a useful line
        elif all(not v for v in pattern):
            contours.append([])
            continue  # none of the mesh lies in the contour; not a useful line
        sub_mesh = mesh.Duplicate()
        if face_match:
            sub_mesh.Faces.DeleteFaces(remove_i, False)
        else:
            sub_mesh.Vertices.Remove(remove_i, True)

        # create the contour polylines by matching segments in ladybug-geometry
        all_segs, contour_segs = [], []
        for geo in sub_mesh.GetNakedEdges():
            lb_geo = to_polyline3d(geo)
            if isinstance(lb_geo, Polyline3D):
                all_segs.extend(lb_geo.segments)
            else:
                all_segs.append(lb_geo)
        for seg in all_segs:
            for i_seg in init_naked_edges:
                if seg.p1.is_equivalent(i_seg.p1, tol) and \
                        seg.p2.is_equivalent(i_seg.p2, tol):
                    break
                elif seg.p1.is_equivalent(i_seg.p2, tol) and \
                        seg.p2.is_equivalent(i_seg.p1, tol):
                    break
            else:  # we have found a new segment for contouring
                contour_segs.append(seg)
        polylines = Polyline3D.join_segments(contour_segs, tol)

        # convert the contour segments to Rhino PolylineCurves and smooth them
        final_contours = []
        if as_lb_geo:
            for cont in polylines:
                if isinstance(cont, Polyline3D):
                    for i in range(smooth_iterations):
                        cont.smooth(smooth_strength)
                final_contours.append(cont)
        else:
            for cont in polylines:
                rhino_pts = [from_point3d(pt) for pt in cont.vertices]
                if isinstance(cont, Polyline3D):
                    rh_poly = rg.Polyline(rhino_pts)
                    for i in range(smooth_iterations):
                        rh_poly.Smooth(smooth_strength)
                else:  # it is a line segment
                    rh_poly = rg.Line(*rhino_pts)
                final_contours.append(rh_poly)
        contours.append(final_contours)

    return contours, thresholds


def label_countours(contours, thresholds, legend_parameters=None):
    """Create text labels for contours.

    Args:
        contours: A list of lists where each sub-list represents contours associated
            with a specific threshold. Sub-lists contain Rhino Polyline objects.
        thresholds: list of numbers for the threshold value associated
            with each contour. The length of this list matches the contours.
        legend_parameters: Ladybug LegendParameters to be used to customize
            the text height and decimal count of the contours. If None, default
            legend parameters will be used. (DefaultL None).

    Returns:
        A list of Rhino geometries in the following order.

        -   updated_contours -- A list of Polylines for contours.

        -   labels -- list of text labels (if text_labels is set to True).
    """
    # convert any input ladybug-geometry to Rhino geometry
    rh_contours = []
    for group in contours:
        rh_cont = []
        for cont in group:
            if isinstance(cont, Polyline3D):
                rhino_pts = [from_point3d(pt) for pt in cont.vertices]
                cont = rg.Polyline(rhino_pts)
            elif isinstance(cont, LineSegment3D):  # it is a line segment
                rhino_pts = [from_point3d(pt) for pt in cont.vertices]
                cont = rg.Line(*rhino_pts)
            rh_cont.append(cont)
        rh_contours.append(rh_cont)

    # get the text size with which to make the labels
    l_par = legend_parameters if legend_parameters is not None else LegendParameters()
    txt_h = l_par.text_height
    if l_par.is_text_height_default:
        lengths = [pl.Length for group in rh_contours for pl in group]
        n = len(lengths)
        s = sorted(lengths)
        if n:
            med_len = (s[n // 2 - 1] / 2.0 + s[n // 2] / 2.0, s[n // 2])[n % 2]
            txt_h = med_len / 100
        else:
            txt_h = 1
    format_str = '%.{}f'.format(l_par.decimal_count)
    font = l_par.font

    # create the labels
    updated_contours, labels = [], []
    for thresh, contour_group in zip(thresholds, rh_contours):
        label_str = format_str % thresh
        group_cont, group_labels = [], []
        for poly in contour_group:
            if isinstance(poly, rg.Polyline):
                poly = poly.ToPolylineCurve()
                pts = poly.DivideByLength(txt_h, True)
                if pts is None or len(pts) < 4:  # not long enough to be subdivided
                    group_cont.append(poly)
                    continue
                pt_index = int(len(pts) / 2)
                text_pt = to_point3d(poly.PointAt(pts[pt_index]))
                label_obj = text_objects(label_str, Plane(o=text_pt), txt_h, font, 1, 3)
                group_labels.append(label_obj)
                split_is = [pts[pt_index - 1], pts[pt_index + 1]]
                split_poly = poly.Split(split_is)
                group_cont.append(split_poly[0])
                group_cont.append(split_poly[-1])
            else:  # it is a line segment; don't bother labeling it
                group_cont.append(poly)
        updated_contours.append(group_cont)
        labels.append(group_labels)
    return updated_contours, labels


def from_geometry(geometry):
    """Generic geometry translation function that works for any ladybug-geometry object.

    This is only recommended for cases where an input geometry stream can contain
    a variety of different objects. When the geometry type is know, it can be
    significantly faster to use the dedicated geometry translator.

    Args:
        geometry: Any 2D or 3D ladybug-geometry object.
    """
    if isinstance(geometry, Point3D):
        return from_point3d(geometry)
    elif isinstance(geometry, Vector3D):
        return from_vector3d(geometry)
    elif isinstance(geometry, Ray3D):
        return from_ray3d(geometry)
    elif isinstance(geometry, LineSegment3D):
        return from_linesegment3d(geometry)
    elif isinstance(geometry, Plane):
        return from_plane(geometry)
    elif isinstance(geometry, Arc3D):
        return from_arc3d(geometry)
    elif isinstance(geometry, Polyline3D):
        return from_polyline3d(geometry)
    elif isinstance(geometry, Mesh3D):
        return from_mesh3d(geometry)
    elif isinstance(geometry, Face3D):
        return from_face3d(geometry)
    elif isinstance(geometry, Polyface3D):
        return from_polyface3d(geometry)
    elif isinstance(geometry, Sphere):
        return from_sphere(geometry)
    elif isinstance(geometry, Cone):
        return from_cone(geometry)
    elif isinstance(geometry, Cylinder):
        return from_cylinder(geometry)
    elif isinstance(geometry, Point2D):
        return from_point2d(geometry)
    elif isinstance(geometry, Vector2D):
        return from_vector2d(geometry)
    elif isinstance(geometry, Ray2D):
        return from_ray2d(geometry)
    elif isinstance(geometry, LineSegment2D):
        return from_linesegment2d(geometry)
    elif isinstance(geometry, Arc2D):
        return from_arc2d(geometry)
    elif isinstance(geometry, Polygon2D):
        return from_polygon2d(geometry)
    elif isinstance(geometry, Polyline2D):
        return from_polyline2d(geometry)
    elif isinstance(geometry, Mesh2D):
        return from_mesh2d(geometry)


def luminaire_objects(luminaire, scale=1):
    """Translate a Honeybee Luminaire object into Rhino geometry.

    Args:
        luminaire: A Honeybee Luminaire object to be converted to Rhino geometry.
        scale: A number for the scale factor to be used in translation. (Default: 1)

    Returns:
        A list of Rhino geometries in the following order.

        -   lum_web -- Rhino geometry representing the candela distribution.

        -   lum_poly -- Rhino geometry representing the luminaire opening.

        -   lum_axes -- Line objects for the C0 and G0 axes of the luminaire.
    """
    luminaire.parse_photometric_data()

    luminaire_web = luminaire_web_to_rhino_breps(luminaire, normalize=True)
    lum_web = place_luminaire_from_object(luminaire, luminaire_web, scale)

    luminaire_poly = create_luminaire_brep(luminaire)
    lum_poly = place_luminaire_from_object(luminaire, luminaire_poly, scale)

    luminaire_axes = create_luminaire_axes(luminaire)
    lum_axes = place_luminaire_from_object(luminaire, luminaire_axes, scale)

    return lum_web, lum_poly, lum_axes


def luminaire_web_to_rhino_breps(luminaire, normalize=True):
    """Generate geometric representation of the candela distribution of a luminaire.

    Args:
        luminaire: A Honeybee Luminaire.
        normalize: Set to True to Normalize candela values.

    Returns:
        List[Rhino.Geometry.Brep]
    """
    # Ensure photometry is parsed
    luminaire._ensure_parsed()

    # Expand symmetry
    horz_deg, candelas = luminaire._expand_horizontal_angles(
        luminaire.horizontal_angles,
        luminaire.candela_values
    )

    vert_deg = luminaire.vertical_angles

    # Convert to radians
    horz = [math.radians(h) for h in horz_deg]
    vert = [math.radians(v) for v in vert_deg]

    # Normalize candela
    if normalize:
        max_cd = luminaire.max_candela or 1.0
        candelas = [
            [v / max_cd for v in row]
            for row in candelas
        ]

    # Scale = max luminous dimension
    mul3d = max(abs(luminaire.width_m), abs(luminaire.length_m))

    # Create vertical-angle curves
    curves = []

    for h_idx, h_ang in enumerate(horz):
        pts = []

        for v_idx, v_ang in enumerate(vert):
            cd = mul3d * candelas[h_idx][v_idx]

            x = cd * math.sin(v_ang) * math.cos(h_ang)
            y = cd * math.sin(v_ang) * math.sin(h_ang)
            z = -cd * math.cos(v_ang)

            pts.append(rg.Point3d(x, y, z))

        curves.append(rg.PolyCurve.CreateControlPointCurve(pts))

    # Create edge surfaces between curves
    breps = []

    for i in range(len(curves) - 1):
        b = rg.Brep.CreateEdgeSurface([curves[i], curves[i + 1]])
        if b:
            breps.append(b)

    return breps


def create_luminaire_brep(luminaire):
    """Create geometric representation of the luminous opening of a Luminaire.

    Args:
        luminaire: A Honeybee Luminaire.

    Returns:
        List[Rhino.Geometry.Brep]
    """
    w = luminaire.width_m
    l = luminaire.length_m  # noqa: E741
    h = luminaire.height_m

    plane = rg.Plane.WorldXY
    origin = rg.Point3d.Origin

    # Implies that the luminous opening is a point
    if round(w, 2) == 0 and round(l, 2) == 0 and round(h, 2) == 0:
        return []
    # Implies that luminous opening is rectangular
    elif w > 0 and l > 0 and round(h, 2) == 0:
        corner_a = rg.Point3d(-l/2, -w/2, 0)
        corner_b = rg.Point3d(l/2, w/2, 0)
        lum_rect = rg.Rectangle3d(plane, corner_a, corner_b).ToNurbsCurve()
        lum_poly = rg.Brep.CreatePlanarBreps([lum_rect])[0]
    # Implies that luminous opening is rectangular with luminous sides
    elif w > 0 and l > 0 and h > 0:
        x_interval = rg.Interval(-l/2, l/2)
        y_interval = rg.Interval(-w/2, w/2)
        z_interval = rg.Interval(-h/2, h/2)
        lum_poly = rg.Box(plane, x_interval, y_interval, z_interval)
    # Implies that the luminous opening is a circle
    elif w < 0 and l < 0 and round(l, 2) == round(w, 2) and round(h, 2) == 0:
        lum_circ = rg.Circle(plane, origin, abs(-w/2)).ToNurbsCurve()
        lum_poly = rg.Brep.CreatePlanarBreps([lum_circ])[0]
    elif w < 0 and round(l, 2) == 0 and round(h, 2) == 0:
        lum_circ = rg.Circle(plane, origin, abs(-w/2)).ToNurbsCurve()
        lum_poly = rg.Brep.CreatePlanarBreps([lum_circ])[0]
    # Implies that the luminous opening is an ellipse
    elif w < 0 and l < 0 and round(l, 2) != round(w, 2) and round(h, 2) == 0:
        lum_ellip = rg.Ellipse(plane, abs(-w/2), abs(-l/2)).ToNurbsCurve()
        lum_poly = rg.Brep.CreatePlanarBreps([lum_ellip])[0]
    # Implies the luminous opening is a vertical cylinder
    elif w < 0 and l < 0 and h > 0 and round(l, 2) == round(w, 2):
        lum_circ = rg.Circle(plane, origin, abs(-w/2))
        lum_poly = rg.Cylinder(lum_circ, h).ToBrep(True, True)
    # Implies the luminous opening is a vertical elliptcal cylinder
    elif w < 0 and l < 0 and h > 0 and round(l, 2) != round(w, 2):
        lum_circ = rg.Circle(plane, origin, 1)
        lum_poly = rg.Cylinder(lum_circ, 1).ToNurbsSurface()
        transf = rg.Transform.Scale(plane, abs(w/2), abs(l/2), abs(h))
        lum_poly.Transform(transf)
        lum_poly = lum_poly.ToBrep().CapPlanarHoles(current_tolerance())
    elif w < 0 and l < 0 and h < 0 and round(l, 2) == round(w, 2) and round(w, 2) == round(h, 2):
        lum_poly = rg.Sphere(rg.Point3d(0, 0, abs(w/2)), abs(w/2))
    # Implies the luminous opening is an ellipsoid
    elif w < 0 and l < 0 and h < 0:
        lum_poly = rg.Sphere(rg.Point3d(0, 0, abs(w/2)), 1).ToNurbsSurface()
        transf = rg.Transform.Scale(
            rg.Plane(rg.Point3d(0, 0, abs(w/2)), rg.Vector3d.ZAxis),
            abs(w/2), abs(l/2), abs(h/2))
        lum_poly.Transform(transf)
    # Implies the luminous opening is a horizontal cylinder
    elif w < 0 and l > 0 and h < 0 and round(w, 2) == round(h, 2):
        lum_circ = rg.Circle(rg.Plane.WorldYZ, rg.Point3d((-l/2), 0, abs(-w/2)), abs(-w/2))
        lum_poly = rg.Cylinder(lum_circ, l).ToBrep(True, True)
    # Implies the luminous opening is a horizontal elliptical cylinder
    elif w < 0 and l > 0 and h < 0 and round(w, 2) != round(h, 2):
        cent_pt = rg.Point3d((h / 2), 0, abs(h / 2))
        lum_circ = rg.Circle(rg.Plane.WorldYZ, cent_pt, 1)
        lum_poly = rg.Cylinder(lum_circ, 1).ToNurbsSurface()
        transf = rg.Transform.Scale(
            rg.Plane(cent_pt, rg.Vector3d.ZAxis), abs(l), abs(w/2), abs(h/2))
        lum_poly.Transform(transf)
        lum_poly = lum_poly.ToBrep().CapPlanarHoles(current_tolerance())
    # Implies the luminous opening is a horizontal cylinder
    elif w > 0 and l < 0 and h < 0 and round(l, 2) == round(h, 2):
        lum_circ = rg.Circle(rg.Plane.WorldZX, rg.Point3d(0, (-w/2), abs(-l/2)), abs(-l/2))
        lum_poly = rg.Cylinder(lum_circ, w).ToBrep(True, True)
    # Implies the luminous opening is a horizontal elliptical cylinder
    elif w > 0 and l < 0 and h < 0 and round(l, 2) != round(h, 2):
        cent_pt = rg.Point3d(0, (-w/2), abs(h/2))
        lum_circ = rg.Circle(rg.Plane.WorldZX, cent_pt, 1)
        lum_poly = rg.Cylinder(lum_circ, 1).ToNurbsSurface()
        transf = rg.Transform.Scale(
            rg.Plane(cent_pt, rg.Vector3d.ZAxis), abs(l/2), abs(w), abs(h/2))
        lum_poly.Transform(transf)
        lum_poly = lum_poly.ToBrep().CapPlanarHoles(current_tolerance())
    # Implies the luminous opening is a vertical circle
    elif w < 0 and round(l) == 0 and h < 0 and round(w, 2) == round(h, 2):
        lum_circ = rg.Circle(rg.Plane.WorldYZ, origin, abs(w/2)).ToNurbsCurve()
        lum_poly = rg.Brep.CreatePlanarBreps([lum_circ])[0]
    # Implies the luminous opening is a vertical ellipse
    elif w < 0 and round(l) == 0 and h < 0 and round(w, 2) != round(h, 2):
        lum_ellip = rg.Ellipse(rg.Plane.WorldYZ, abs(w/2), abs(h/2)).ToNurbsCurve()
        lum_poly = rg.Brep.CreatePlanarBreps([lum_circ])[0]

    return lum_poly


def create_luminaire_axes(luminaire):
    """Draw the C0-G0 axes for a Luminaire according to IES LM-63.

    Args:
        luminaire: A Honeybee Luminaire.

    Returns:
        [C0 axis, G0 axis]
    """
    # Ensure photometry is parsed
    luminaire.parse_photometric_data()

    # Dimensions
    width = luminaire.width_m
    length = luminaire.length_m

    # IES rule: circular luminaires
    # width < 0, length == 0: use width magnitude
    if abs(length) < 1e-6 and width < 0:
        length = abs(width)

    # Fallback if dimensions are zero
    if abs(length) < 1e-6:
        length = 0.5  # default

    origin = rg.Point3d(0, 0, 0)

    # C0 axis
    c0_axis = rg.Line(
        origin,
        rg.Point3d(1.2 * length / 2.0, 0, 0)
    )

    # G0 axis
    g0_axis = rg.Line(
        origin,
        rg.Point3d(0, 0, -2.0 * length / 2.0)
    )

    return [c0_axis, g0_axis]


def place_luminaire_from_object(luminaire, luminaire_web, scale):
    """Take a Luminaire object, place its geometry at all points in its LuminaireZone,
    applying spin, tilt, and rotation.

    Args:
        luminaire: A Honeybee Luminaire.
        luminaire_web: Geometric representation of the candela distribution of
            of the luminaire.
        scale: Scalar value to scale the geometry.

    Returns:
        List[Rhino.Geometry.Brep]
    """
    if luminaire.luminaire_zone is None:
        return [luminaire_web]

    luminaire_zone = luminaire.luminaire_zone
    geometry = []

    for instance in luminaire_zone.instances:
        geo = transform_geometry(
            luminaire_web,
            spin=instance.spin,
            tilt=instance.tilt,
            rotation=instance.rotation,
            translation=instance.point,
            scale=scale
        )
        geometry.append(geo)

    return geometry


def transform_geometry(geometry, spin=0, tilt=0, rotation=0, translation=None, scale=1.0):
    """Transform a geometry or list of geometries based on spin, tilt, rotation,
    translation, scale.

    Args:
        geometry: Rhino geometry to transform.
        spin: Number for the spin (Z-axis) in degrees.
        tilt: Number for the tilt (Y-axis) in degrees.
        rotation: Number for the rotation (Z-axis) in degrees.
        translation: A Ladybug Vector3D or Point3D, or a tuple of three numbers
            for the translation in the X, Y, and Z directions. If None, no
            translation is applied.
        scale: Number for the scale factor.

    Returns:
        Transformed geometry or list of geometries.
    """
    if not isinstance(geometry, list):
        geometry = [geometry]

    geometry = [copy.deepcopy(g) for g in geometry]

    norm_vec = rg.Vector3d(0, 0, 1)
    plane = rg.Plane(rg.Point3d(0, 0, 0), norm_vec)
    origin = rg.Point3d(0, 0, 0)

    # Scale
    if scale != 1.0:
        s = rg.Transform.Scale(plane, scale, scale, scale)
        for g in geometry:
            g.Transform(s)

    # Spin (Z-axis)
    if spin != 0:
        t = rg.Transform.Rotation(math.radians(spin), rg.Vector3d.ZAxis, origin)
        for g in geometry:
            g.Transform(t)

    # Tilt (Y-axis)
    if tilt != 0:
        t = rg.Transform.Rotation(math.radians(tilt), rg.Vector3d.YAxis, origin)
        for g in geometry:
            g.Transform(t)

    # Rotate (Z-axis)
    if rotation != 0:
        t = rg.Transform.Rotation(math.radians(rotation), rg.Vector3d.ZAxis, origin)
        for g in geometry:
            g.Transform(t)

    # Translate
    x, y, z = translation
    t = rg.Transform.Translation(x, y, z)
    for g in geometry:
        g.Transform(t)

    return geometry if len(geometry) > 1 else geometry[0]
